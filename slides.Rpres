plyr & ggplot2
========================================================
author: Diogo Melo
date: 2015/04/30
font-family: 'Helvetica'
width: 1366 
height: 768

plyr
========================================================

Plyr é um conjunto de funções que substituem a familia apply.

Queremos aplicar uma mesma função em subconjuntos

- Mais flexivel 
- Fácil de paralelizar
- Com algumas facilidades importantes

***

![](slides-figure/splitApplyCombine.png)
 
Syntaxe geral
========================================================

```{r, eval=FALSE}
__ply()
```

Primeira letra indica o tipo da entrada:

```{r, eval=FALSE}
a_ply(), d_ply(), l_ply()
```

Segunda letra indica o tipo da saída:

```{r, eval=FALSE}
_aply(), _dply(), _lply()
```

 - (a)rray
 - (l)ist
 - (d)ata.frame

l_ply
========================================================

  Listas tem divisão natural, então basta identificar o objeto de entrada e a função
  
```{r}
library(plyr)
simple_list <- list('zero' = rnorm(5), 
                    'cinco' = rnorm(5, 5), 
                    'dez' = rnorm(5, 10))
print(simple_list)
```

l_ply
========================================================

  Listas tem divisão natural, então basta identificar o objeto de entrada e a função

```{r}
llply(simple_list, sum)
```
```{r, eval = FALSE}
#identico a:
lapply(simple_list, sum)
```

l_ply
========================================================

  Podemos também mudar o tipo da saida (diferente do lapply())

```{r}
laply(simple_list, mean)
```
```{r}
ldply(simple_list, quantile)
```

l_ply
========================================================

  Bom para conversões

```{r}
laply(simple_list, identity)
```

```{r}
ldply(simple_list, identity)
```

a_ply
========================================================

  Arrays não tem divisão natural, então um segundo argumento é necessario para
  indicar o sentido da operação sendo feita
  
```{r}
str(iris3)
```
```{r}
aaply(iris3, 3, colMeans)
```

Levemente diferente do apply.

```{r}
apply(iris3, 3, colMeans)
```

a_ply
========================================================

```{r}
aaply(iris3, 3, colMeans)
```

Ou...

```{r}
aaply(iris3, c(2, 3), mean)
```

a_ply
========================================================

Novamente podemos mudar a saída

 - data.frame:
 
```{r}
adply(iris3, 3, colMeans, .id = 'Species')
```

a_ply
========================================================

Novamente podemos mudar a saída

- list: 

```{r}
alply(iris3, 3, colMeans, .dims = TRUE)
```

a_ply
========================================================

O a_ply() tb é útil para converter arrays:

 - data.frames

```{r}
iris_df = adply(iris3, 3, .id = 'Species')
head(iris_df)
```

a_ply
========================================================

O a_ply() tb é útil para converter arrays:

 - listas

```{r}
iris_list = alply(iris3, 3, .dims = TRUE)
names(iris_list)
class(iris_list[[1]])
str(iris_list[[1]])
```

d_ply
========================================================

d_ply é a função mais complexa

 - seu uso geralmente envolve o uso de funções auxiliares; 
 - muita da funcionalidade básica é mais simples no dplyr;
 - ainda é útil para operações complicadas, que operam em mais de uma linha simultaneamente.
 - básicamente um aggregate-on-steroids
 
d_ply
========================================================

```{r}
library(gapminder)
str(gapminder)
``` 
 
d_ply
========================================================

O segundo argumento é um coluna do data.frame que será usada para subdividi-lo

```{r}
dlply(gapminder, 'country')[[1]]
``` 

d_ply
========================================================

Principal ponto de discórdia: 
  - O data.frame é subdividido de acordo com uma (ou mais) coluna(s) de indicadores, mas os "sub"-data.frames ainda contém essas colunas!

```{r}
dlply(gapminder, 'country')[[1]]
```

d_ply
========================================================

Isso é um problema quando queremos fazer operações nas colunas numéricas apenas:

```{r}
head(ddply(gapminder, 'country', mean))
```

d_ply
========================================================

Isso é um problema quando queremos fazer operações nas colunas numéricas apenas:

```{r, eval=FALSE}
head(ddply(gapminder, 'country', mean))
```

A função numcolwise() resolve esse problema, mas ela é aplicada na função!!

```{r}
head(ddply(gapminder, .(country), numcolwise(mean)))
```


d_ply
========================================================

A função .() permite omitir as aspas e fazer operações nas colunas:

```{r}
head(ddply(gapminder, .(country, log(year)), numcolwise(mean)), 12)
``` 


d_ply
========================================================

Podemos também usar formulas:

```{r}
head(ddply(gapminder, ~ country + log(year), numcolwise(mean)), 12)
``` 

d_ply
========================================================

- Se quisermos operar sobre mais de uma coluna numérica simultaneamente, o numcolwise não serve
- Nesse caso, o melhor é usar uma função que faça a indexação desejada:

```{r}
l_iris <- dlply(iris, ~ Species, '[', 1:3)
llply(l_iris, cor)[[1]]
``` 

d_ply
========================================================

Ou, usando o pipe (%>%) do pacote magrittr

```{r}
library(magrittr)
dlply(iris, ~ Species, '[', 1:3) %>% llply(., cor)
``` 


plyr + magrittr + evolqg
========================================================

```{r}
library(evolqg)
data(dentus)
dlply(dentus, ~ species, '[', 1:4) %>% 
  llply(cov) %>% 
  ldply(MeanMatrixStatistics, .id = 'Species')
``` 

ggplot2
========================================================
left: 35%

  "ggplot2 is a plotting system for R, based on the grammar of graphics, which tries to take the good parts of base and lattice graphics and none of the bad parts. It takes care of many of the fiddly details that make plotting a hassle (like drawing legends) as well as providing a powerful model of graphics that makes it easy to produce complex multi-layered graphics."
  
***

```{r intro, echo=FALSE}
library(ggplot2)
ggplot(gapminder, aes(year, lifeExp, group = interaction(year, continent), color = continent)) + 
  geom_boxplot() + geom_jitter() + theme_bw() + labs(x = 'year', y = 'Life Expectancy') + 
  geom_smooth(aes(group = continent), method = 'lm')
```

ggplot
=======================================================

Todas os plots no ggplot tem a mesma estrutura e dependem bastante do objeto de entrada:

 - SEMPRE um data.frame;
 - Cada linha é uma observação;
 - Geralmente é melhor usar data.frames no formato "narrow";
 - Cores, grupos, separações em paineis são todas definidas por fatores (yay!!)

ggplot
=======================================================

Regra geral:

```{r, eval=FALSE}
ggplot(data_frame_entrada, aes(x = coluna_eixo_x, 
                               y = coluna_eixo_y,
                               group = coluna_agrupadora, 
                               color = coluna_das_cores)) 
+ geom_tipo_do_grafico(opcoes que não dependem dos dados, 
                       aes(opcoes que dependem))
```

ggplot - mudando cores
=======================================================

```{r, eval=FALSE}
ggplot(gapminder, aes(x = log(gdpPercap), 
                      y = log(lifeExp),
                      group = country, 
                      color = year)) + geom_point()
```

```{r, eval=FALSE}
ggplot(gapminder, aes(x = log(gdpPercap), 
                      y = log(lifeExp),
                      group = country, 
                      color = continent)) + geom_point()
```

ggplot - mudando cores
=======================================================

```{r year, echo=FALSE, figs.only=TRUE}
ggplot(gapminder, aes(x = log(gdpPercap), 
                      y = log(lifeExp),
                      group = country, 
                      color = year)) + geom_point()
```

***

```{r continent, echo=FALSE, figs.only=TRUE}
ggplot(gapminder, aes(x = log(gdpPercap), 
                      y = log(lifeExp),
                      group = country, 
                      color = continent)) + geom_point()
```
